/*
Идея KMP в одной фразе

Когда совпадение прерывается, мы не возвращаемся назад в тексте, а понимаем:

«Мы уже что-то знаем о начале шаблона — можно сдвинуть его дальше, сохранив часть совпадённого».

Чтобы так сделать, мы должны знать, какая часть начала шаблона совпадает с его же концом.

Это и делает префикс-функция (или LPS-массив).


Префикс строки — это её "начало".
Примеры строки "abcab":

a

ab

abc

abca

abcab (весь — тоже префикс)

Суффикс — её “конец”.
Примеры:

b

ab

cab

bcab

abcab
*/



#include <bits/stdc++.h>
using namespace std;

vector<int> computeLPS(const string &p) {
    int m = p.size();
    vector<int> lps(m, 0);
    int len = 0;

    for (int i = 1; i < m; ) {
        if (p[i] == p[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

vector<int> KMP(const string &t, const string &p) {
    vector<int> lps = computeLPS(p);
    vector<int> res;

    int i = 0, j = 0;
    int tSize = t.size(), pSize = p.size();

    while (i < tSize) {
        /* Случай №1 — символ совпал
        Если текущие символы совпали:
        двигаемся дальше в тексте (i++)
        двигаемся дальше в паттерне (j++)
        Это простая ситуация: продолжаем совпадение.  */
        if (t[i] == p[j]) {
            i++; j++;
        }

        /* Случай №2 — весь паттерн совпал
        1)Почему i - pSize?
        Потому что:
        i сейчас УЖЕ стоит на позиции после последнего совпавшего символа
        длина паттерна pSize
        значит начало совпадения = i - pSize


        2) Почему j = lps[j - 1] ?
        Паттерн полностью совпал, например:
        text:   ababab…
        pat:    ababa

        И после этого может сразу начаться новое совпадение.

        Например:
        ababab
        ababa
          ^

        Мы смотрим, какой самый длинный префикс совпадает с суффиксом, и продолжаем с него.
        */
        if (j == pSize) {
            res.push_back(i - pSize);
            j = lps[j - 1];
        }

        /* Случай №3 — символы НЕ совпадают
        Если несовпадение и j != 0
        Это означает:
        мы уже что-то совпадили (j > 0)
        и сейчас всё сломалось

        Например:

        t: ababc…
        p: ababd…
                ^
        Мы не возвращаемся назад в тексте.
        Мы пытаемся начать сравнение с того места в шаблоне, которое может продолжать текущий суффикс.

        Делаем:
        j = lps[j - 1];
        То есть:
        «Откатываемся до самого длинного совпадающего префикса».
        */
        else if (i < tSize && t[i] != p[j]) {

            /*
            Если j == 0
            Значит:
            мы даже НЕ начали сравнение (первая буква паттерна не совпала)
            Тогда логично просто двигаться в тексте:
            */
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }

    return res;
}



/*
Давай покажу всё на простом примере
Текст:
a b a b a c a b a b a b

Паттерн:
a b a b a


LPS = [0, 0, 1, 2, 3]

Работа цикла:

a==a, i=1,j=1

b==b, i=2,j=2

a==a, i=3,j=3

b==b, i=4,j=4

a==a, i=5,j=5 → j==m → нашли совпадение

res.push(5 - 5) = 0

j = lps[4] = 3
(продолжаем с "aba")

пытаемся дальше…
— и снова найдём совпадение на позиции 2
— и снова на позиции 4
и т.д.
*/
